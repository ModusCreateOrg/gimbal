import { resolvePath } from '@modus/gimbal-core/lib/utils/fs';
import bytes from 'bytes';
import deepmerge from 'deepmerge';
import globby from 'globby';
import minimatch from 'minimatch';
import explore from 'source-map-explorer';
import { ExploreBundleResult, ExploreResult } from 'source-map-explorer/dist/types';
import { Report, ReportItem } from '@/typings/command';
import { PluginOptions } from '@/typings/config/plugin';
import { Options } from '@/typings/module/registry';
import { BundleObject, BundleType, Config, PluginConfig, defaultConfig, meta, type } from './config';

type RunModuleFn = (options: Options) => Promise<Report>;

interface RawReport extends ExploreResult {
  bundle: string;
}

const bytesConfig = { unitSeparator: ' ' };

export const getThreshold = (file: string, bundleConfig: BundleType): string | undefined => {
  if (typeof bundleConfig === 'string') {
    return undefined;
  }

  const key = Object.keys(bundleConfig.thresholds).find((threshold: string): boolean => minimatch(file, threshold));

  return key && bundleConfig.thresholds[key];
};

export const parseBundle = (rawBundle: RawReport, bundleConfig: BundleType): ReportItem => {
  const data: ReportItem[] = [];
  let success = true;

  rawBundle.bundles.forEach((bundleResult: ExploreBundleResult): void => {
    Object.keys(bundleResult.files).forEach((file: string): void => {
      const { size } = bundleResult.files[file];
      const threshold = getThreshold(file, bundleConfig as BundleObject);
      const rawThreshold = threshold == null ? threshold : bytes(threshold);
      const fileSuccess = rawThreshold == null ? true : size <= rawThreshold;

      if (success) {
        success = fileSuccess;
      }

      data.push({
        label: file,
        rawLabel: file,
        rawThreshold,
        rawValue: size,
        success: fileSuccess,
        threshold,
        type,
        value: bytes(size, bytesConfig),
      });
    });
  });

  return {
    data,
    label: rawBundle.bundle,
    rawLabel: rawBundle.bundle,
    success,
    type,
  };
};

const parseBundles = (config: Config): Config => {
  const catchAll = config.bundles.filter((bundleConfig: BundleType): boolean =>
    typeof bundleConfig === 'string'
      ? bundleConfig === '**/*.js'
      : (bundleConfig as BundleObject).path === '**/*.js' && (bundleConfig as BundleObject).disable !== true,
  );
  const exclusions = config.bundles.filter((bundleConfig: BundleType): boolean =>
    typeof bundleConfig === 'string' ? bundleConfig[0] === '!' : (bundleConfig as BundleObject).path[0] === '!',
  );
  const inclusions = config.bundles.filter((bundleConfig: BundleType): boolean => {
    if (typeof bundleConfig === 'string') {
      return bundleConfig[0] !== '!' && bundleConfig !== '**/*.js';
    }

    return (bundleConfig as BundleObject).path[0] !== '!' && (bundleConfig as BundleObject).path !== '**/*.js';
  });

  // we need to order the bundle configs. The first group is the inclusions, next is the catch all,
  // next the exclusions.
  const bundles = [...inclusions, ...catchAll, ...exclusions];

  return {
    ...config,
    bundles,
  };
};

const parseConfig = (config: Config): Config => {
  const sourceConfig: Config = config.bundles ? { ...defaultConfig, bundles: [] } : { ...defaultConfig };

  return parseBundles(deepmerge(sourceConfig, config));
};

// eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars
export const runModule = (_pluginConfig?: PluginConfig): RunModuleFn => async ({
  config,
  context,
}: Options): Promise<Report> => {
  const auditConfig = parseConfig(config || {});
  const buildDir = context.config.get('configs.buildDir');
  const cwd = context.config.get('configs.cwd');
  const globBase = resolvePath(cwd, buildDir as string);
  const globs: string[] = auditConfig.bundles.map((glob: BundleType): string => {
    const normalizedGlob: BundleObject = typeof glob === 'string' ? { path: glob, thresholds: {} } : glob;
    const { path } = normalizedGlob;

    // need to move the ! to the front so globby can ignore it
    return path[0] === '!' ? `!${resolvePath(globBase, path.substr(1))}` : resolvePath(globBase, path);
  });

  const paths = await globby(globs);
  const raw = await Promise.all(
    paths.map(
      async (bundle: string): Promise<false | RawReport> => {
        try {
          // SME will complain if sourcemaps contain just one file, but we don't control that
          // in bundles generated by 3rd parties like webpack runtime or Ionic
          const explored = await explore(bundle);

          return {
            bundle,
            ...explored,
          };
        } catch {
          return false;
        }
      },
    ),
  );

  const data = [
    ...(raw as RawReport[]).filter(Boolean).map(
      (entry: RawReport): ReportItem => {
        const globMatch = globs.find((glob: string): boolean => minimatch(entry.bundle, glob));
        const index = globs.indexOf(globMatch as string);
        const bundleConfig = auditConfig.bundles[index];

        return parseBundle(entry, bundleConfig);
      },
    ),
  ];
  const success = data.every((item: ReportItem): boolean => item.success);

  return {
    data: [
      {
        data,
        label: 'Source Map Explorer Audits',
        rawLabel: 'Source Map Explorer Audits',
        success,
        type,
      },
    ],
    raw,
    success,
  };
};

export const registerModule = async ({ context }: PluginOptions, pluginConfig: Config): Promise<void> => {
  context.module.register(type, meta, runModule(pluginConfig));
};
